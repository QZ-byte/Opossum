All project .py files dump
Generated: 2025-10-27T12:13:54.277444
Project root: c:\Users\Q#\Desktop\Raccon Build 12.92


--- FILE: main.py ---
from ui.main_ui import RacconApp

if __name__ == "__main__":
    app = RacconApp(db_path="raccon.db")
    app.run()


--- FILE: services\db.py ---
import sqlite3
from typing import Tuple, Iterable, Optional


class Database:
    def __init__(self, path: str):
        self.path = path
        self.conn = sqlite3.connect(self.path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self._init_schema()

    def _init_schema(self):
        cur = self.conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL DEFAULT '',
                tags TEXT NOT NULL DEFAULT '',
                created_at TEXT NOT NULL DEFAULT (datetime('now'))
            )
            """
        )
        self.conn.commit()
        cur.close()

    def execute(self, sql: str, params: Tuple = ()) -> None:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        self.conn.commit()
        cur.close()

    def fetchall(self, sql: str, params: Tuple = ()) -> Iterable[sqlite3.Row]:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        rows = cur.fetchall()
        cur.close()
        return rows

    def fetchone(self, sql: str, params: Tuple = ()) -> Optional[sqlite3.Row]:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        row = cur.fetchone()
        cur.close()
        return row

    def close(self):
        self.conn.close()


--- FILE: services\notes_service.py ---
# services/notes_service.py
import json
import html
import os
from typing import List, Tuple, Optional
from datetime import datetime
from services.db import Database


class NotesService:
    def __init__(self, db: Database):
        self.db = db
        self._ensure_format_meta()

    def _ensure_format_meta(self):
        try:
            self.db.execute("ALTER TABLE notes ADD COLUMN format_meta TEXT NOT NULL DEFAULT '{}'")
        except Exception:
            pass

    def create_note(self, title: str, content: str = "", tags: str = "", format_meta: str = "{}") -> None:
        fm = self._normalize_format_meta(format_meta)
        self.db.execute(
            "INSERT INTO notes(title, content, tags, format_meta, created_at) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)",
            (title, content, tags, fm)
        )

    def get_all_notes(self) -> List[Tuple]:
        rows = self.db.fetchall("SELECT id, title, tags, created_at FROM notes ORDER BY id DESC")
        return [tuple(r) for r in rows] if rows else []

    def get_note_by_id(self, note_id: int) -> Optional[Tuple]:
        # Попробовать получить формат_meta вместе с остальными полями
        try:
            row = self.db.fetchone(
                "SELECT id, title, content, tags, created_at, COALESCE(format_meta, '{}') as format_meta FROM notes WHERE id = ?",
                (note_id,)
            )
            if row:
                return tuple(row)
            return None
        except Exception:
            # Если схема старая и column missing — вернуть 6-элементный кортеж с дефолтом
            row = self.db.fetchone(
                "SELECT id, title, content, tags, created_at FROM notes WHERE id = ?",
                (note_id,)
            )
            if row:
                vals = tuple(row)
                return (*vals, "{}")
            return None

    def search_notes(self, query: str) -> List[Tuple]:
        q = f"%{query}%"
        rows = self.db.fetchall(
            "SELECT id, title, tags, created_at FROM notes WHERE title LIKE ? OR tags LIKE ? ORDER BY id DESC",
            (q, q)
        )
        return [tuple(r) for r in rows] if rows else []

    def update_note(self, note_id: int, title: str, content: str, tags: str, format_meta: str = "{}") -> None:
        fm = self._normalize_format_meta(format_meta)
        self.db.execute(
            "UPDATE notes SET title = ?, content = ?, tags = ?, format_meta = ? WHERE id = ?",
            (title, content, tags, fm, note_id)
        )

    def delete_note(self, note_id: int) -> None:
        self.db.execute("DELETE FROM notes WHERE id = ?", (note_id,))

    def export_note_md(self, note_id: int, path: str) -> None:
        note = self.get_note_by_id(note_id)
        if not note:
            raise ValueError("Заметка не найдена")
        _id, title, content, tags, created_at, _ = note
        title_text = title or "(без заголовка)"
        lines = [
            f"# {title_text}",
            "",
            f"- ID: {_id}",
            f"- Создано: {created_at}",
            f"- Теги: {tags or ''}",
            "",
            content or ""
        ]
        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))

    def export_note_html(self, note_id: int, path: str) -> None:
        note = self.get_note_by_id(note_id)
        if not note:
            raise ValueError("Заметка не найдена")
        _id, title, content, tags, created_at, _ = note
        title_safe = html.escape(title or "(без заголовка)")
        content_safe = html.escape(content or "").replace("\n", "<br>\n")
        tags_safe = html.escape(tags or "")
        created_safe = html.escape(created_at or "")
        html_doc = f"""<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>{title_safe}</title>
<style>
body {{ font-family: Segoe UI, Arial, sans-serif; max-width: 900px; margin: 2rem auto; color: #222; }}
.meta {{ color: #555; font-size: 0.9rem; margin-bottom: 0.8rem; }}
.content {{ margin-top: 1rem; line-height: 1.6; }}
hr {{ margin: 1rem 0; }}
</style>
</head>
<body>
<h1>{title_safe}</h1>
<div class="meta">
  <div><strong>ID:</strong> {_id}</div>
  <div><strong>Создано:</strong> {created_safe}</div>
  <div><strong>Теги:</strong> {tags_safe}</div>
</div>
<hr>
<div class="content">
  {content_safe}
</div>
</body>
</html>
"""
        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            f.write(html_doc)

    def _normalize_format_meta(self, fm) -> str:
        if fm is None:
            return "{}"
        if isinstance(fm, dict):
            try:
                return json.dumps(fm, ensure_ascii=False)
            except Exception:
                return "{}"
        if isinstance(fm, str):
            try:
                json.loads(fm)
                return fm
            except Exception:
                return "{}"
        return "{}"


--- FILE: services\paws\crypto_utils.py ---
from cryptography.fernet import Fernet
import base64, hashlib

def derive_key(master_password: str) -> bytes:
    """Из мастер-пароля делаем ключ для Fernet (через SHA256)."""
    digest = hashlib.sha256(master_password.encode()).digest()
    return base64.urlsafe_b64encode(digest)

def encrypt_password(master_password: str, plain: str) -> str:
    key = derive_key(master_password)
    f = Fernet(key)
    return f.encrypt(plain.encode()).decode()

def decrypt_password(master_password: str, token: str) -> str:
    key = derive_key(master_password)
    f = Fernet(key)
    return f.decrypt(token.encode()).decode()


--- FILE: services\paws\generator.py ---
import random, string

def generate_password(length=16, digits=True, upper=True, symbols=True):
    chars = list(string.ascii_lowercase)
    if digits:
        chars += list(string.digits)
    if upper:
        chars += list(string.ascii_uppercase)
    if symbols:
        chars += list("!@#$%^&*()-_=+[]{};:,.<>?")
    return "".join(random.choice(chars) for _ in range(length))


--- FILE: services\paws\passwords_service.py ---
import sqlite3
from pathlib import Path
from .crypto_utils import encrypt_password, decrypt_password

DB_PATH = Path("paws.db")


class PasswordsService:
    def __init__(self, master_password: str):
        self.master_password = master_password
        self.conn = sqlite3.connect(DB_PATH)
        self._init_db()

    def _init_db(self):
        cur = self.conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS passwords (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            service TEXT NOT NULL,
            username TEXT,
            password_enc TEXT NOT NULL,
            notes TEXT
        )
        """)
        self.conn.commit()

    # --- CRUD ---
    def add_entry(self, service: str, username: str, password_plain: str, notes: str = ""):
        enc = encrypt_password(self.master_password, password_plain)
        cur = self.conn.cursor()
        cur.execute(
            "INSERT INTO passwords(service, username, password_enc, notes) VALUES (?, ?, ?, ?)",
            (service, username, enc, notes)
        )
        self.conn.commit()

    def get_entry(self, service: str):
        """Получить запись по имени сервиса"""
        cur = self.conn.cursor()
        cur.execute("SELECT id, service, username, password_enc, notes FROM passwords WHERE service=?", (service,))
        row = cur.fetchone()
        if not row:
            return None
        pid, service, username, enc, notes = row
        plain = decrypt_password(self.master_password, enc)
        return {"id": pid, "service": service, "username": username, "password": plain, "notes": notes}

    def get_entry_by_id(self, entry_id: int):
        """Получить запись по ID (для UI)"""
        cur = self.conn.cursor()
        cur.execute("SELECT id, service, username, password_enc, notes FROM passwords WHERE id=?", (entry_id,))
        row = cur.fetchone()
        if not row:
            return None
        pid, service, username, enc, notes = row
        plain = decrypt_password(self.master_password, enc)
        return {"id": pid, "service": service, "username": username, "password": plain, "notes": notes}

    def list_entries(self):
        """Список всех записей (без паролей, только мета)"""
        cur = self.conn.cursor()
        cur.execute("SELECT id, service, username, notes FROM passwords")
        return cur.fetchall()

    def delete_entry(self, entry_id: int):
        cur = self.conn.cursor()
        cur.execute("DELETE FROM passwords WHERE id=?", (entry_id,))
        self.conn.commit()


--- FILE: services\paws\sync_google.py ---
# Заглушка: позже подключим Google Drive API
def upload_to_google(file_path: str):
    print(f"[GoogleSync] Загружаем {file_path} в Google Drive...")

def download_from_google(file_path: str):
    print(f"[GoogleSync] Скачиваем {file_path} из Google Drive...")


--- FILE: services\paws\sync_telegram.py ---
# Заглушка: позже подключим Telethon или python-telegram-bot
def upload_to_telegram(file_path: str):
    print(f"[TelegramSync] Загружаем {file_path} в Telegram...")

def download_from_telegram(file_path: str):
    print(f"[TelegramSync] Скачиваем {file_path} из Telegram...")


--- FILE: ui\debug_ui.py ---
# ui/debug_ui.py
import tkinter as tk
from tkinter import ttk
import sys, logging, queue, time, os, datetime, io

class _StreamProxy:
    def __init__(self, q, name):
        self.q = q
        self.name = name
    def write(self, data):
        if data:
            self.q.put((self.name, str(data)))
    def flush(self):
        pass

class _QueueLoggingHandler(logging.Handler):
    def __init__(self, q):
        super().__init__()
        self.q = q
    def emit(self, record):
        try:
            msg = self.format(record)
            self.q.put(("log", msg))
        except Exception:
            pass

class DebugUI:
    def __init__(self, master, autostart=False):
        self.win = tk.Toplevel(master)
        self.win.title("Debugger")
        self.win.geometry("880x520")

        self.output = tk.Text(self.win, wrap="word", state="disabled", bg="black", fg="lime")
        self.output.pack(fill="both", expand=True, padx=6, pady=6)

        ctrl = ttk.Frame(self.win); ctrl.pack(fill="x", padx=6, pady=(0,6))
        self.start_btn = ttk.Button(ctrl, text="▶ Старт", command=self.start); self.start_btn.pack(side="left", padx=4)
        self.stop_btn = ttk.Button(ctrl, text="⏹ Стоп", command=self.stop); self.stop_btn.pack(side="left", padx=4)
        self.save_btn  = ttk.Button(ctrl, text="💾 Сохранить", command=self.save); self.save_btn.pack(side="left", padx=4)
        self.mode_var = tk.StringVar(value="all")
        ttk.Radiobutton(ctrl, text="All", variable=self.mode_var, value="all").pack(side="left", padx=6)
        ttk.Radiobutton(ctrl, text="Errors only", variable=self.mode_var, value="errors").pack(side="left")

        # очередь и буфер
        self.q = queue.Queue()
        self.buffer = io.StringIO()

        # сохранить оригиналы
        self._orig_stdout = sys.stdout
        self._orig_stderr = sys.stderr
        self._orig_handlers = logging.getLogger().handlers[:]

        # logging handler
        self._log_handler = _QueueLoggingHandler(self.q)
        self._log_handler.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s", "%H:%M:%S"))

        # флаг активности
        self.active = False

        # запуск поллинга
        self._poll()

        if autostart:
            self.start()

    def _append(self, line: str):
        self.output.configure(state="normal")
        self.output.insert("end", line + "\n")
        self.output.see("end")
        self.output.configure(state="disabled")

    def _poll(self):
        try:
            while True:
                src, data = self.q.get_nowait()
                for ln in str(data).splitlines():
                    if not ln:
                        continue
                    ts = time.strftime("[%H:%M:%S]")
                    if self.mode_var.get() == "errors":
                        if src == "log":
                            if "WARNING" in ln or "ERROR" in ln or "CRITICAL" in ln:
                                pass
                            else:
                                continue
                        elif src == "stderr":
                            pass
                        else:
                            continue
                    out = f"{ts} [{src}] {ln}"
                    self.buffer.write(out + "\n")
                    self._append(out)
        except queue.Empty:
            pass
        self.win.after(120, self._poll)

    def start(self):
        if self.active:
            self._append("[DEBUG] already started")
            return
        sys.stdout = _StreamProxy(self.q, "stdout")
        sys.stderr = _StreamProxy(self.q, "stderr")
        root_logger = logging.getLogger()
        root_logger.handlers = [self._log_handler]
        root_logger.setLevel(logging.DEBUG)
        self.active = True
        self._append("[DEBUG] started")

    def stop(self):
        if not self.active:
            self._append("[DEBUG] not active")
            return
        sys.stdout = self._orig_stdout
        sys.stderr = self._orig_stderr
        logging.getLogger().handlers = self._orig_handlers
        self.active = False
        self._append("[DEBUG] stopped")

    def save(self, path: str = None):
        if path is None:
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            path = os.path.join(os.path.dirname(os.path.dirname(__file__)), f"debug_log_{ts}.txt")
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(self.buffer.getvalue())
            self._append(f"[DEBUG] saved to {path}")
        except Exception as e:
            self._append(f"[DEBUG] save error: {e}")

    # совместимость с write/flush
    def write(self, data):
        if data:
            self.q.put(("custom", str(data)))
    def flush(self):
        pass


--- FILE: ui\dev_cli.py ---
# ui/dev_cli.py
"""
DevCLI - небольшая встроенная консоль для разработчика.

Команды:
  help                       - показать список команд
  tables                     - показать таблицы в sqlite
  notes                      - вывести все заметки
  sql <запрос>               - выполнить SQL запрос и показать результаты
  dump                       - вывести содержимое .py файлов в окно
  dump save                  - сохранить каждый .py в dcli_dumps/<name>.txt
  dump all [имя_файла]       - собрать все .py в один файл dcli_dumps/all_code_<ts>.txt
  debug                      - открыть окно Debugger (графический)
  clear                      - очистить окно вывода
"""
import os
import sys
import sqlite3
import datetime
import tkinter as tk
from tkinter import ttk

# Внутренний helper для работы с БД (ожидается, что передаётся объект с методом fetchall)
class _SafeDB:
    def __init__(self, db_obj):
        self._db = db_obj

    def fetchall(self, query: str):
        # Поддерживаем два варианта: объект Database с методом fetchall или sqlite3.Connection
        if self._db is None:
            raise RuntimeError("DB not provided")
        if hasattr(self._db, "fetchall"):
            return self._db.fetchall(query)
        # Если передан sqlite3.Connection
        cur = self._db.cursor()
        cur.execute(query)
        return cur.fetchall()


class DevCLI:
    def __init__(self, master, db=None, notes_service=None):
        """
        master      - parent TK widget (обычно root или frame)
        db          - объект базы данных либо sqlite3.Connection; должен поддерживать fetchall(query)
        notes_service - сервис заметок с методом get_all_notes()
        """
        self.master = master
        self.db = _SafeDB(db) if db is not None else None
        self.notes_service = notes_service

        self.win = tk.Toplevel(master)
        self.win.title("DCLI")
        self.win.geometry("900x520")

        # Текстовый вывод (консоль)
        self.output = tk.Text(self.win, wrap="word", state="disabled",
                              bg="black", fg="lime", insertbackground="lime", padx=6, pady=6)
        self.output.pack(fill="both", expand=True, padx=6, pady=(6, 0))

        # Панель ввода
        entry_frame = ttk.Frame(self.win)
        entry_frame.pack(fill="x", padx=6, pady=6)

        self.cmd_entry = ttk.Entry(entry_frame)
        self.cmd_entry.pack(side="left", fill="x", expand=True)
        self.cmd_entry.bind("<Return>", self._on_enter)

        ttk.Button(entry_frame, text="Выполнить", command=self._run_cmd).pack(side="left", padx=6)
        ttk.Button(entry_frame, text="Очистить", command=self._clear).pack(side="left")

        # Начальное сообщение
        self._print("ГОТОВ. Введите 'help' для списка команд.")

    # ----------------- базовые утилиты -----------------
    def _print(self, text: str):
        self.output.configure(state="normal")
        self.output.insert("end", text + "\n")
        self.output.see("end")
        self.output.configure(state="disabled")

    def _clear(self):
        self.output.configure(state="normal")
        self.output.delete("1.0", "end")
        self.output.configure(state="disabled")

    def _on_enter(self, _event=None):
        self._run_cmd()

    def _run_cmd(self):
        cmd = self.cmd_entry.get().strip()
        self.cmd_entry.delete(0, "end")
        self.execute(cmd)

    # ----------------- основной парсер команд -----------------
    def execute(self, cmd: str):
        if not cmd:
            return
        self._print(f"> {cmd}")

        parts = cmd.split()
        head = parts[0].lower()

        try:
            if head == "help":
                self._cmd_help()
            elif head == "tables":
                self._cmd_tables()
            elif head == "notes":
                self._cmd_notes()
            elif head == "sql":
                self._cmd_sql(" ".join(parts[1:]))
            elif head == "dump":
                # Подкоманды: dump, dump save, dump all
                if len(parts) == 1:
                    self._dump_code(print_only=True)
                elif parts[1] == "save":
                    self._dump_code(print_only=False)
                elif parts[1] == "all":
                    name = parts[2] if len(parts) > 2 else None
                    path = self._dump_code_all(out_filename=name)
                    self._print(f"[dump all] Сохранено в: {path}")
                else:
                    self._print("Использование: dump | dump save | dump all [имя_файла]")
            elif head == "debug":
                self._cmd_debug()
            elif head == "clear":
                self._clear()
            else:
                self._print("Неизвестная команда. help — список команд.")
        except Exception as e:
            self._print(f"[ERROR] {e}")

    # ----------------- реализации команд -----------------
    def _cmd_help(self):
        lines = [
            "Команды:",
            "  help                       - показать этот список",
            "  tables                     - показать таблицы sqlite",
            "  notes                      - вывести все заметки",
            "  sql <запрос>               - выполнить SQL запрос",
            "  dump                       - вывести .py в окно",
            "  dump save                  - сохранить каждый .py в dcli_dumps/",
            "  dump all [имя_файла]       - собрать все .py в один файл",
            "  debug                      - открыть Debugger окно",
            "  clear                      - очистить окно вывода"
        ]
        for l in lines:
            self._print(l)

    def _cmd_tables(self):
        if self.db is None:
            self._print("[tables] DB не предоставлена")
            return
        try:
            rows = self.db.fetchall("SELECT name FROM sqlite_master WHERE type='table'")
            names = ", ".join(r[0] for r in rows) if rows else "(нет таблиц)"
            self._print("Таблицы: " + names)
        except Exception as e:
            self._print(f"[tables] Ошибка: {e}")

    def _cmd_notes(self):
        if self.notes_service is None:
            self._print("[notes] notes_service не предоставлен")
            return
        try:
            notes = self.notes_service.get_all_notes()
            if not notes:
                self._print("(нет заметок)")
                return
            for n in notes:
                self._print(str(n))
        except Exception as e:
            self._print(f"[notes] Ошибка: {e}")

    def _cmd_sql(self, query: str):
        if not query:
            self._print("Использование: sql <запрос>")
            return
        if self.db is None:
            self._print("[sql] DB не предоставлена")
            return
        try:
            rows = self.db.fetchall(query)
            if not rows:
                self._print("(пусто)")
                return
            for r in rows:
                self._print(str(tuple(r)))
        except sqlite3.Error as e:
            self._print(f"[SQL Error] {e}")
        except Exception as e:
            self._print(f"[sql] Ошибка: {e}")

    def _cmd_debug(self):
        # Открываем отдельное окно DebugUI; используем относительный импорт внутри пакета ui
        try:
            from .debug_ui import DebugUI
        except Exception:
            # fallback: попробуем импорт как корневой модуль (если dev_cli.py не в ui/)
            try:
                import importlib, os
                sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
                DebugUI = importlib.import_module("ui.debug_ui").DebugUI
            except Exception as e:
                self._print(f"[debug] Не удалось импортировать DebugUI: {e}")
                return

        # Удерживаем ссылку на окно, чтобы оно не было собранным GC
        if not hasattr(self, "_debug_window") or self._debug_window is None or not self._debug_window.win.winfo_exists():
            try:
                self._debug_window = DebugUI(self.win if hasattr(self, "win") else self.master)
                self._print("[debug] Окно Debugger открыто")
            except Exception as e:
                self._print(f"[debug] Ошибка при создании окна: {e}")
        else:
            try:
                self._debug_window.win.lift()
                self._print("[debug] Окно Debugger поднято на передний план")
            except Exception:
                pass

    # ----------------- дамп кода по файлам -----------------
    def _dump_code(self, print_only: bool = True):
        """
        Обходит проект от корня (родитель папки ui/) и:
          - print_only=True: печатает содержимое .py файлов в окно.
          - print_only=False: сохраняет каждый .py в dcli_dumps/<имя>.txt
        """
        try:
            root_dir = os.path.dirname(os.path.dirname(__file__))
            dump_dir = os.path.join(root_dir, "dcli_dumps")
            if not print_only:
                os.makedirs(dump_dir, exist_ok=True)

            for dirpath, _, files in os.walk(root_dir):
                # пропускаем __pycache__ и скрытые каталоги
                if os.path.basename(dirpath).startswith("__pycache__"):
                    continue
                for fname in sorted(files):
                    if not fname.endswith(".py"):
                        continue
                    path = os.path.join(dirpath, fname)
                    rel = os.path.relpath(path, root_dir)
                    try:
                        with open(path, "r", encoding="utf-8") as fh:
                            content = fh.read()
                    except Exception as e:
                        self._print(f"[dump] Ошибка чтения {rel}: {e}")
                        continue

                    if print_only:
                        self._print(f"\n--- {rel} ---")
                        # печатаем содержимое построчно, чтобы не раздувать память
                        for line in content.splitlines():
                            self._print(line)
                    else:
                        out_path = os.path.join(dump_dir, fname.replace(".py", ".txt"))
                        try:
                            with open(out_path, "w", encoding="utf-8") as out:
                                out.write(content)
                            self._print(f"Сохранено: {out_path}")
                        except Exception as e:
                            self._print(f"[dump save] Ошибка записи {out_path}: {e}")

            self._print("[dump] Готово.")
        except Exception as e:
            self._print(f"[dump] Ошибка: {e}")

    # ----------------- объединённый дамп всех файлов в один -----------------
    def _dump_code_all(self, out_filename: str = None) -> str:
        """
        Собирает все .py файлы проекта в один файл.
        Возвращает путь к сохранённому файлу.
        """
        root_dir = os.path.dirname(os.path.dirname(__file__))
        dumps_dir = os.path.join(root_dir, "dcli_dumps")
        os.makedirs(dumps_dir, exist_ok=True)

        if out_filename:
            safe_name = out_filename
        else:
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_name = f"all_code_{ts}.txt"

        out_path = os.path.join(dumps_dir, safe_name)

        with open(out_path, "w", encoding="utf-8") as out_f:
            header = (
                f"All project .py files dump\nGenerated: {datetime.datetime.now().isoformat()}\n"
                f"Project root: {root_dir}\n\n"
            )
            out_f.write(header)
            for dirpath, _, files in os.walk(root_dir):
                # пропускаем виртуальные и системные каталоги
                base = os.path.basename(dirpath)
                if base.startswith("__pycache__") or base.startswith("."):
                    continue
                rel_dir = os.path.relpath(dirpath, root_dir)
                for fname in sorted(files):
                    if not fname.endswith(".py"):
                        continue
                    file_path = os.path.join(dirpath, fname)
                    rel_path = os.path.join(rel_dir, fname) if rel_dir != "." else fname
                    out_f.write(f"\n--- FILE: {rel_path} ---\n")
                    try:
                        with open(file_path, "r", encoding="utf-8") as fh:
                            out_f.write(fh.read() + "\n")
                    except Exception as e:
                        out_f.write(f"[ERROR reading file: {e}]\n")

        return out_path


--- FILE: ui\main_ui.py ---
# ui/main_ui.py
import tkinter as tk
from tkinter import ttk

from services.db import Database
from services.notes_service import NotesService
from ui.notes_ui import NotesUI
from ui.passwords_ui import PasswordsUI


class RacconApp:
    def __init__(self, db_path: str = "raccon.db"):
        self.root = tk.Tk()
        self.root.title("Raccoon Pro")
        self.root.geometry("900x600")

        # --- сервисы ---
        self.db = Database(db_path)
        self.notes_service = NotesService(self.db)

        # --- Notebook (вкладки) ---
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True)

        # --- Заметки ---
        self.notes_tab = NotesUI(self.notebook, self.notes_service)
        self.notebook.add(self.notes_tab.frame, text="Заметки")

        # --- Задачи (пока пустая) ---
        self.tasks_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.tasks_tab, text="Задачи")

        # --- Пароли ---
        # Подключаем PasswordsUI вместо пустого Frame
        # master_password можно будет вынести в отдельный ввод/настройки
        self.passwords_tab = PasswordsUI(self.notebook, master_password="secret123")
        self.notebook.add(self.passwords_tab.get_frame(), text="Пароли")

        # --- DCLI кнопка ---
        dcli_btn = ttk.Button(self.root, text="DCLI", command=self.open_dcli)
        dcli_btn.pack(side="bottom", pady=4)

    def open_dcli(self):
        from ui.dev_cli import DevCLI
        DevCLI(self.root, db=self.db, notes_service=self.notes_service)

    def run(self):
        self.root.mainloop()


--- FILE: ui\notes_ui.py ---
# ui/notes_ui.py
import json
import tkinter as tk
from tkinter import ttk, messagebox, filedialog


class FormattingPanel(tk.Toplevel):
    """Полноценное окно форматирования с Pin/Unpin.
    При Pin панель следует за окном редактора, при этом сохраняет свой текущий размер.
    """
    WIDTH = 300
    DEFAULT_HEIGHT = 420

    def __init__(self, editor_win: tk.Toplevel, text_widget: tk.Text, format_meta: dict | None):
        super().__init__(editor_win)
        self.editor_win = editor_win
        self.text = text_widget
        self.format_meta = format_meta or {}
        self.pinned = False
        self._following = False
        self._editor_configure_handler = None

        self.title("Панель форматирования")
        self.geometry(f"{self.WIDTH}x{self.DEFAULT_HEIGHT}")
        self.protocol("WM_DELETE_WINDOW", self.hide)
        self.withdraw()  # скрыта по умолчанию

        # Если редактор уничтожается — закрыть панель
        try:
            self.editor_win.bind("<Destroy>", lambda e: self.destroy(), add="+")
        except Exception:
            pass

        self._build_ui()
        self._ensure_tags()

    def _build_ui(self):
        frm = ttk.Frame(self, padding=8)
        frm.pack(fill="both", expand=True)

        header = ttk.Frame(frm)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Панель форматирования", font=("", 10, "bold")).pack(side="left")
        self.pin_btn = ttk.Button(header, text="Pin", width=8, command=self._toggle_pin)
        self.pin_btn.pack(side="right")

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=(6, 8))

        ttk.Button(frm, text="Жирный", command=lambda: self.apply_style("bold")).pack(fill="x", pady=4)
        ttk.Button(frm, text="Курсив", command=lambda: self.apply_style("italic")).pack(fill="x", pady=4)
        ttk.Button(frm, text="Подчёркнутый", command=lambda: self.apply_style("underline")).pack(fill="x", pady=4)
        ttk.Button(frm, text="Зачёркнутый", command=lambda: self.apply_style("strike")).pack(fill="x", pady=4)

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=(8, 8))
        ttk.Button(frm, text="Очистить формат", command=self.clear_meta).pack(fill="x", pady=4)
        ttk.Button(frm, text="Закрыть панель", command=self.hide).pack(fill="x", pady=(8, 0))

    def _ensure_tags(self):
        try:
            self.text.tag_configure("fmt_bold", font=("Segoe UI", 10, "bold"))
            self.text.tag_configure("fmt_italic", font=("Segoe UI", 10, "italic"))
            self.text.tag_configure("fmt_underline", underline=1)
            self.text.tag_configure("fmt_strike", overstrike=1)
        except Exception:
            pass

    # ---------------- Pin / follow logic ----------------
    def _toggle_pin(self):
        self.pinned = not self.pinned
        self.pin_btn.config(text="Unpin" if self.pinned else "Pin")
        if self.pinned:
            try:
                self.transient(self.editor_win)
            except Exception:
                pass
            self._start_following_editor()
        else:
            try:
                self.transient(None)
            except Exception:
                pass
            self._stop_following_editor()

    def _start_following_editor(self):
        if self._following:
            return
        self._following = True

        def _on_editor_configure(event=None):
            try:
                self.editor_win.update_idletasks()
                ex = self.editor_win.winfo_rootx()
                ey = self.editor_win.winfo_rooty()
                ew = self.editor_win.winfo_width()
                eh = self.editor_win.winfo_height()
                if ew <= 1 or eh <= 1:
                    return
                # сохраняем текущие размеры панели, чтобы не перезаписывать пользовательские настройки
                try:
                    cur_w = max(self.winfo_width(), 1)
                    cur_h = max(self.winfo_height(), 1)
                    if cur_w <= 1:
                        cur_w = self.WIDTH
                    if cur_h <= 1:
                        cur_h = eh
                except Exception:
                    cur_w = self.WIDTH
                    cur_h = eh
                px = ex + ew + 10
                py = ey
                # Меняем только позицию, сохраняя размеры
                self.geometry(f"{cur_w}x{cur_h}+{px}+{py}")
            except Exception:
                pass

        # Сохраняем обработчик для возможности отписки
        self._editor_configure_handler = _on_editor_configure
        try:
            self.editor_win.bind("<Configure>", self._editor_configure_handler, add="+")
            self._editor_configure_handler()
        except Exception:
            # fallback: попытка позиционировать один раз
            try:
                self._position_right_of_editor()
            except Exception:
                pass

    def _stop_following_editor(self):
        if not self._following:
            return
        self._following = False
        try:
            if self._editor_configure_handler:
                # Попытка удалить конкретный обработчик; tkinter не всегда гарантирует удаление по ссылке
                self.editor_win.unbind("<Configure>", self._editor_configure_handler)
        except Exception:
            try:
                # Грубый fallback: удалить все Configure-обработчики
                self.editor_win.unbind("<Configure>")
            except Exception:
                pass
        finally:
            self._editor_configure_handler = None

    def _position_right_of_editor(self):
        try:
            ex = self.editor_win.winfo_rootx()
            ey = self.editor_win.winfo_rooty()
            ew = self.editor_win.winfo_width()
            eh = self.editor_win.winfo_height()
            if ew <= 1 or eh <= 1:
                self.after(30, self._position_right_of_editor)
                return
            px = ex + ew + 10
            py = ey
            # при первоначальном позиционировании используем текущие размеры панели
            try:
                cur_w = max(self.winfo_width(), 1)
                cur_h = max(self.winfo_height(), 1)
                if cur_w <= 1:
                    cur_w = self.WIDTH
                if cur_h <= 1:
                    cur_h = eh
            except Exception:
                cur_w = self.WIDTH
                cur_h = eh
            self.geometry(f"{cur_w}x{cur_h}+{px}+{py}")
        except Exception:
            pass

    def show(self):
        if self.pinned:
            self._position_right_of_editor()
        self.deiconify()
        self.lift()
        self._apply_all_meta_tags()

    def hide(self):
        self.withdraw()

    # ---------------- форматирование метаданных ----------------
    def _index_to_offset(self, idx: str) -> int:
        line, col = map(int, str(idx).split("."))
        offset = 0
        for l in range(1, line):
            line_text = self.text.get(f"{l}.0", f"{l}.end")
            offset += len(line_text) + 1
        offset += col
        return offset

    def _offset_to_index(self, offset: int) -> str:
        line = 1
        while True:
            line_text = self.text.get(f"{line}.0", f"{line}.end")
            line_len = len(line_text) + 1
            if offset < line_len:
                col = offset
                return f"{line}.{col}"
            offset -= line_len
            line += 1

    def _get_selection_bounds_offsets(self):
        try:
            s = self.text.index("sel.first")
            e = self.text.index("sel.last")
        except tk.TclError:
            return None
        return self._index_to_offset(s), self._index_to_offset(e)

    def _record_range(self, style: str, start_off: int, end_off: int):
        if start_off >= end_off:
            return
        lst = self.format_meta.get(style, [])
        lst.append([start_off, end_off])
        self.format_meta[style] = lst
        self._apply_meta_tag(style, start_off, end_off)

    def apply_style(self, style_key: str):
        bounds = self._get_selection_bounds_offsets()
        if not bounds:
            messagebox.showinfo("Форматирование", "Выделите текст, который нужно отформатировать")
            return
        start_off, end_off = bounds
        self._record_range(style_key, start_off, end_off)

    def clear_meta(self):
        if not messagebox.askyesno("Очистка", "Удалить все метаданные форматирования?"):
            return
        self.format_meta.clear()
        self._remove_all_meta_tags()
        messagebox.showinfo("Очистка", "Метаданные удалены")

    def _apply_meta_tag(self, style: str, start_off: int, end_off: int):
        tag = self._style_to_tag(style)
        try:
            start_idx = self._offset_to_index(start_off)
            end_idx = self._offset_to_index(end_off)
            self.text.tag_add(tag, start_idx, end_idx)
        except Exception:
            pass

    def _apply_all_meta_tags(self):
        self._remove_all_meta_tags()
        for style, ranges in self.format_meta.items():
            for r in ranges:
                try:
                    self._apply_meta_tag(style, int(r[0]), int(r[1]))
                except Exception:
                    pass

    def _remove_all_meta_tags(self):
        for tag in ("fmt_bold", "fmt_italic", "fmt_underline", "fmt_strike"):
            try:
                self.text.tag_remove(tag, "1.0", "end")
            except Exception:
                pass

    def _style_to_tag(self, style: str) -> str:
        return {
            "bold": "fmt_bold",
            "italic": "fmt_italic",
            "underline": "fmt_underline",
            "strike": "fmt_strike"
        }.get(style, "fmt_bold")

    def get_format_meta_json(self) -> str:
        return json.dumps(self.format_meta, ensure_ascii=False)


# ---------------- NotesUI ----------------
class NotesUI:
    def __init__(self, master, notes_service):
        self.master = master
        self.notes_service = notes_service
        self.frame = ttk.Frame(master)

        control = ttk.Frame(self.frame)
        control.pack(fill="x", padx=8, pady=8)

        ttk.Label(control, text="Заголовок:").pack(side="left")
        self.title_entry = ttk.Entry(control, width=30)
        self.title_entry.pack(side="left", padx=6)

        ttk.Label(control, text="Теги:").pack(side="left")
        self.tags_entry = ttk.Entry(control, width=20)
        self.tags_entry.pack(side="left", padx=6)

        ttk.Button(control, text="Добавить", command=self.add_note).pack(side="left", padx=6)

        ttk.Label(control, text="Поиск:").pack(side="left", padx=(20, 0))
        self.search_entry = ttk.Entry(control, width=25)
        self.search_entry.pack(side="left", padx=6)

        ttk.Button(control, text="Искать", command=self.search_notes).pack(side="left", padx=6)
        ttk.Button(control, text="Сброс", command=self.load_notes).pack(side="left", padx=6)

        table_frame = ttk.Frame(self.frame)
        table_frame.pack(fill="both", expand=True, padx=8, pady=6)

        self.tree = ttk.Treeview(
            table_frame,
            columns=("id", "title", "tags", "created_at"),
            show="headings",
            height=16
        )
        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        table_frame.rowconfigure(0, weight=1)
        table_frame.columnconfigure(0, weight=1)

        self.tree.heading("id", text="ID")
        self.tree.heading("title", text="Заголовок")
        self.tree.heading("tags", text="Теги")
        self.tree.heading("created_at", text="Создано")

        self.tree.column("id", width=60, anchor="center")
        self.tree.column("title", width=360, anchor="w")
        self.tree.column("tags", width=180, anchor="w")
        self.tree.column("created_at", width=160, anchor="center")

        self.tree.bind("<Double-1>", self._on_double_click)

        bottom = ttk.Frame(self.frame)
        bottom.pack(fill="x", padx=8, pady=8)

        ttk.Button(bottom, text="Удалить", command=self.delete_note).pack(side="left")
        ttk.Button(bottom, text="Просмотр", command=self.view_note).pack(side="left", padx=6)
        ttk.Button(bottom, text="Редактировать", command=self.edit_note).pack(side="left", padx=6)

        self.load_notes()

    def get_frame(self):
        return self.frame

    # ---------------- CRUD и поиск ----------------
    def load_notes(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        try:
            rows = self.notes_service.get_all_notes()
            if rows:
                for note in rows:
                    self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить заметки: {e}")

    def add_note(self):
        title = self.title_entry.get().strip()
        tags = self.tags_entry.get().strip()
        if not title:
            messagebox.showwarning("Ошибка", "Заголовок не может быть пустым")
            return
        try:
            self.notes_service.create_note(title, "", tags)
            self.title_entry.delete(0, "end")
            self.tags_entry.delete(0, "end")
            self.title_entry.focus_set()
            self.load_notes()
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def search_notes(self):
        q = self.search_entry.get().strip()
        if not q:
            self.load_notes()
            return
        try:
            results = self.notes_service.search_notes(q)
            for row in self.tree.get_children():
                self.tree.delete(row)
            if not results:
                messagebox.showinfo("Поиск", "Ничего не найдено")
                return
            for note in results:
                self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def delete_note(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Ошибка", "Выберите заметку для удаления")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        if messagebox.askyesno("Подтвердите", "Удалить выбранную заметку?"):
            try:
                self.notes_service.delete_note(note_id)
                self.load_notes()
            except Exception as e:
                messagebox.showerror("Ошибка", str(e))

    def view_note(self):
        sel = self.tree.selection()
        if not sel:
            self.tree.showwarning("Ошибка", "Выберите заметку для просмотра")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        try:
            note = self.notes_service.get_note_by_id(note_id)
            if not note:
                messagebox.showerror("Ошибка", "Заметка не найдена")
                return
            if len(note) == 6:
                _, title, content, tags, created_at, _ = note
            else:
                _, title, content, tags, created_at = note
            messagebox.showinfo(
                "Заметка",
                f"Заголовок: {title}\nТеги: {tags}\nСоздано: {created_at}\n\n{content}"
            )
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def edit_note(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Ошибка", "Выберите заметку для редактирования")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        note = self.notes_service.get_note_by_id(note_id)
        if not note:
            messagebox.showerror("Ошибка", "Заметка не найдена")
            return

        if len(note) == 6:
            _, title, content, tags, created_at, format_meta = note
        else:
            _, title, content, tags, created_at = note
            format_meta = "{}"

        try:
            original_meta = json.loads(format_meta or "{}")
        except Exception:
            original_meta = {}
        working_meta = json.loads(json.dumps(original_meta))

        win = tk.Toplevel(self.master)
        win.title("Редактировать заметку")
        win.geometry("920x560")
        win.transient(self.master)

        container = ttk.Frame(win)
        container.pack(fill="both", expand=True, padx=8, pady=8)

        editor_frame = ttk.Frame(container)
        editor_frame.pack(side="left", fill="both", expand=True)

        top_fields = ttk.Frame(editor_frame)
        top_fields.pack(fill="x", padx=4, pady=(0, 6))

        ttk.Label(top_fields, text="Заголовок:").grid(row=0, column=0, sticky="w")
        title_entry = ttk.Entry(top_fields)
        title_entry.grid(row=0, column=1, sticky="ew", padx=8)
        title_entry.insert(0, title or "")
        top_fields.columnconfigure(1, weight=1)

        ttk.Label(top_fields, text="Теги:").grid(row=1, column=0, sticky="w", pady=(6, 0))
        tags_entry = ttk.Entry(top_fields)
        tags_entry.grid(row=1, column=1, sticky="ew", padx=8, pady=(6, 0))
        tags_entry.insert(0, tags or "")

        content_frame = ttk.Frame(editor_frame)
        content_frame.pack(fill="both", expand=True, padx=4, pady=4)

        text_area = tk.Text(content_frame, wrap="word")
        text_area.pack(side="left", fill="both", expand=True)
        text_area.insert("1.0", content or "")

        text_vsb = ttk.Scrollbar(content_frame, orient="vertical", command=text_area.yview)
        text_vsb.pack(side="right", fill="y")
        text_area.configure(yscrollcommand=text_vsb.set)

        # панель форматирования — полноценное окно, скрыто по умолчанию
        panel = FormattingPanel(win, text_area, working_meta)

        footer = ttk.Frame(win)
        footer.pack(fill="x", padx=12, pady=(6, 10))

        left_box = ttk.Frame(footer)
        left_box.pack(side="left")

        def toggle_panel():
            try:
                if panel.state() == "normal":
                    panel.hide()
                else:
                    panel.show()
            except Exception:
                panel.show()

        ttk.Button(left_box, text="Редакт.", command=toggle_panel).pack(side="left")

        def export_md():
            path = filedialog.asksaveasfilename(title="Сохранить как Markdown", defaultextension=".md",
                                                filetypes=[("Markdown", "*.md"), ("Все файлы", "*.*")])
            if not path:
                return
            try:
                cur_title = title_entry.get().strip()
                cur_tags = tags_entry.get().strip()
                cur_content = text_area.get("1.0", "end-1c")
                self.notes_service.update_note(
                    note_id, cur_title, cur_content, cur_tags, panel.get_format_meta_json()
                )
                self.notes_service.export_note_md(note_id, path)
                messagebox.showinfo("Экспорт", f"Сохранено: {path}")
            except Exception as e:
                messagebox.showerror("Экспорт", f"Ошибка: {e}")

        def export_html():
            path = filedialog.asksaveasfilename(title="Сохранить как HTML", defaultextension=".html",
                                                filetypes=[("HTML", "*.html"), ("Все файлы", "*.*")])
            if not path:
                return
            try:
                cur_title = title_entry.get().strip()
                cur_tags = tags_entry.get().strip()
                cur_content = text_area.get("1.0", "end-1c")
                self.notes_service.update_note(
                    note_id, cur_title, cur_content, cur_tags, panel.get_format_meta_json()
                )
                self.notes_service.export_note_html(note_id, path)
                messagebox.showinfo("Экспорт", f"Сохранено: {path}")
            except Exception as e:
                messagebox.showerror("Экспорт", f"Ошибка: {e}")

        ttk.Button(left_box, text="Экспорт MD", command=export_md).pack(side="left", padx=(8, 8))
        ttk.Button(left_box, text="Экспорт HTML", command=export_html).pack(side="left")

        right_box = ttk.Frame(footer)
        right_box.pack(side="right")

        def save_and_close():
            new_title = title_entry.get().strip()
            new_tags = tags_entry.get().strip()
            new_content = text_area.get("1.0", "end-1c")
            if not new_title:
                messagebox.showwarning("Ошибка", "Заголовок не может быть пустым")
                return
            try:
                self.notes_service.update_note(
                    note_id, new_title, new_content, new_tags, panel.get_format_meta_json()
                )
                try:
                    panel.destroy()
                except Exception:
                    pass
                self.load_notes()
                win.destroy()
            except Exception as e:
                messagebox.showerror("Ошибка", str(e))

        def cancel_and_close():
            try:
                panel.destroy()
            except Exception:
                pass
            win.destroy()

        ttk.Button(right_box, text="Сохранить", command=save_and_close).pack(side="right", padx=6)
        ttk.Button(right_box, text="Отмена", command=cancel_and_close).pack(side="right")

        panel._apply_all_meta_tags()
        title_entry.focus_set()

    def _on_double_click(self, event):
        sel = self.tree.identify_row(event.y)
        if sel:
            self.tree.selection_set(sel)
            self.edit_note()


--- FILE: ui\passwords_ui.py ---
import tkinter as tk
from tkinter import ttk, messagebox
from services.paws.passwords_service import PasswordsService
from services.paws.generator import generate_password


class PasswordsUI:
    def __init__(self, master, master_password: str):
        self.master = master
        self.service = PasswordsService(master_password)

        self.frame = ttk.Frame(master)

        # Верхняя панель управления
        control = ttk.Frame(self.frame)
        control.pack(fill="x", padx=8, pady=8)

        ttk.Label(control, text="Сервис:").pack(side="left")
        self.service_entry = ttk.Entry(control, width=20)
        self.service_entry.pack(side="left", padx=6)

        ttk.Label(control, text="Логин:").pack(side="left")
        self.username_entry = ttk.Entry(control, width=20)
        self.username_entry.pack(side="left", padx=6)

        ttk.Button(control, text="Добавить", command=self.add_entry).pack(side="left", padx=6)
        ttk.Button(control, text="Сгенерировать", command=self.generate_and_insert).pack(side="left", padx=6)

        # Таблица
        table_frame = ttk.Frame(self.frame)
        table_frame.pack(fill="both", expand=True, padx=8, pady=6)

        self.tree = ttk.Treeview(
            table_frame,
            columns=("id", "service", "username", "notes"),
            show="headings",
            height=16
        )
        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        table_frame.rowconfigure(0, weight=1)
        table_frame.columnconfigure(0, weight=1)

        self.tree.heading("id", text="ID")
        self.tree.heading("service", text="Сервис")
        self.tree.heading("username", text="Логин")
        self.tree.heading("notes", text="Заметки")

        self.tree.column("id", width=40, anchor="center")
        self.tree.column("service", width=160, anchor="w")
        self.tree.column("username", width=160, anchor="w")
        self.tree.column("notes", width=200, anchor="w")

        # Нижняя панель
        bottom = ttk.Frame(self.frame)
        bottom.pack(fill="x", padx=8, pady=8)

        ttk.Button(bottom, text="Показать пароль", command=self.show_password).pack(side="left")
        ttk.Button(bottom, text="Удалить", command=self.delete_entry).pack(side="left", padx=6)

        self.load_entries()

    def get_frame(self):
        return self.frame

    # ---------------- CRUD ----------------
    def load_entries(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        try:
            rows = self.service.list_entries()
            for note in rows:
                self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить пароли: {e}")

    def add_entry(self):
        service = self.service_entry.get().strip()
        username = self.username_entry.get().strip()
        if not service:
            messagebox.showwarning("Ошибка", "Сервис не может быть пустым")
            return
        # генерируем пароль сразу
        password = generate_password()
        self.service.add_entry(service, username, password)
        self.service_entry.delete(0, "end")
        self.username_entry.delete(0, "end")
        self.load_entries()
        messagebox.showinfo("Добавлено", f"Пароль для {service} создан и сохранён")

    def generate_and_insert(self):
        pwd = generate_password()
        self.username_entry.insert(0, f"gen:{pwd}")

    def show_password(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Ошибка", "Выберите запись")
            return
        entry_id = self.tree.item(sel[0])["values"][0]
        entry = self.service.get_entry_by_id(entry_id)
        if not entry:
            messagebox.showerror("Ошибка", "Запись не найдена")
            return
        messagebox.showinfo("Пароль", f"Сервис: {entry['service']}\nЛогин: {entry['username']}\nПароль: {entry['password']}")

    def delete_entry(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("Ошибка", "Выберите запись для удаления")
            return
        entry_id = self.tree.item(sel[0])["values"][0]
        if messagebox.askyesno("Подтвердите", "Удалить выбранную запись?"):
            self.service.delete_entry(entry_id)
            self.load_entries()

